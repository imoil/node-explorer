# **Vue.js Project setup**

최신 Vue.js 프로젝트를 구성하는 가장 표준적인 방법은 공식 빌드 도구인 **Vite**를 사용하는 것입니다. 과거에는 Vue CLI가 주로 사용되었지만, 현재는 비교할 수 없이 빠른 속도와 간결한 설정으로 Vite가 완벽한 표준으로 자리 잡았습니다.

프로젝트 생성부터 주요 툴체인 설정까지의 절차는 다음과 같습니다.

## **핵심 툴체인 (The Modern Vue.js Toolchain)**

최신 Vue 프로젝트는 다음과 같은 도구들의 조합으로 구성됩니다.

1. **빌드 도구: Vite** 🚀  
   * ES 모듈을 기반으로 한 초고속 개발 서버와 최적화된 빌드 기능을 제공합니다. Vue의 창시자인 에반 유(Evan You)가 직접 만들었으며, Vue와의 호환성이 완벽합니다.  
2. **라우팅: Vue Router** 🛣️  
   * Vue의 공식 라우팅 라이브러리로, 페이지 이동 및 중첩된 라우트(Nested Routes) 등 SPA(Single Page Application)의 화면 전환을 관리합니다.  
3. **상태 관리: Pinia** 🍍  
   * Vue의 공식 상태 관리 라이브러리입니다. 기존의 Vuex보다 훨씬 직관적이고 간단한 문법을 가지며, 타입스크립트 지원이 뛰어납니다. 현재는 Pinia 사용이 표준으로 권장됩니다.  
4. **타입스크립트 (TypeScript)** ⌨️  
   * 이제는 선택이 아닌 필수에 가까운 표준입니다. 코드의 안정성과 유지보수성을 크게 향상시켜 대규모 프로젝트에서도 실수를 줄여줍니다.  
5. **코드 린터 & 포맷터: ESLint & Prettier** ✨  
   * **ESLint**는 잠재적인 코드 오류나 버그를 찾아주고, **Prettier**는 정해진 규칙에 따라 코드 스타일(들여쓰기, 따옴표 등)을 통일시켜 줍니다. 협업 시 코드의 일관성을 유지하는 데 필수적입니다.

## **프로젝트 생성 절차 (Step-by-Step)**

터미널(Terminal)이나 명령 프롬프트(Command Prompt)를 열고 다음 절차를 따르세요.

### **1단계: create-vue 실행**

아래 명령어를 입력하여 프로젝트 생성 스캐폴딩(scaffolding)을 시작합니다. 이 명령어는 최신 버전의 Vue 프로젝트 생성 도구를 자동으로 다운로드하여 실행합니다.

```bash
npm create vue@latest
```

### **2단계: 프로젝트 이름 및 옵션 설정**

명령어를 실행하면 대화형 프롬롬프트가 나타나 프로젝트 이름과 함께 다양한 옵션을 선택하라고 안내합니다. 키보드 방향키와 엔터키를 사용하여 선택할 수 있습니다.

```bash
✔ Project name: … <your-project-name>
```

프로젝트 이름을 입력한 후, 다음과 같은 핵심 옵션들을 설정하게 됩니다. **현대적인 개발 환경에서는 대부분 Yes를 선택하는 것이 좋습니다.**

* **Add TypeScript?** … **Yes**  
  * 타입스크립트를 추가합니다.  
* **Add JSX Support?** … No  
  * React의 JSX와 유사한 문법을 Vue에서 사용하고 싶을 때만 선택합니다. 특별한 경우가 아니면 No로 둡니다.  
* **Add Vue Router for Single Page Application development?** … **Yes**  
  * Vue Router를 추가하여 SPA를 구성합니다.  
* **Add Pinia for state management?** … **Yes**  
  * Pinia를 추가하여 상태 관리를 합니다.  
* **Add Vitest for Unit Testing?** … Yes  
  * 단위 테스트를 위한 Vitest를 추가할지 선택합니다. (필요에 따라 선택)  
* **Add an End-to-End Testing Solution?** … No  
  * Cypress나 Playwright 같은 E2E 테스트 도구를 추가할지 선택합니다. (필-요에 따라 선택)  
* **Add ESLint for code quality?** … **Yes**  
  * ESLint를 추가하여 코드 품질을 관리합니다.  
* **Add Prettier for code formatting?** … **Yes**  
  * Prettier를 추가하여 코드 스타일을 통일합니다.

### **3단계: 프로젝트 설치 및 실행**

모든 설정이 완료되면, 터미널에 다음과 같은 안내가 표시됩니다. 안내에 따라 명령어를 순서대로 입력합니다.

```bash
# 1. 생성된 프로젝트 폴더로 이동  
cd <your-project-name>

# 2. 프로젝트에 필요한 패키지(의존성) 설치  
npm install

# 3. 개발 서버 실행  
npm run dev
```

npm run dev 명령어를 실행하면 Vite 개발 서버가 시작되고, 터미널에 로컬 서버 주소(예: http://localhost:5173/)가 나타납니다. 이 주소를 웹 브라우저에서 열면 "Welcome to Vue.js\!"와 같은 초기 화면을 볼 수 있습니다.

이제 당신은 최신 툴체인이 완벽하게 구성된 Vue.js 프로젝트 개발을 시작할 준비가 되었습니다\! 이 구조 안에서 컴포넌트를 만들고, 라우터를 설정하며, Pinia를 통해 상태를 관리하는 방식으로 개발을 진행하게 됩니다.


# **최적화된 트리 컴포넌트 아키텍처 구현**

본 프로젝트는 보고서에서 제안된 **대규모 트리 구조를 위한 최적의 웹 아키텍처**를 실제로 구현한 것입니다. Vue.js와 Nuxt.js, shadcn-vue를 기반으로 하며, 다음과 같은 핵심 기능을 포함합니다.

* **지연 로딩 (Lazy Loading)**: 사용자가 폴더를 열 때만 해당 폴더의 자식 데이터를 서버에 요청하여 초기 로딩 속도를 극대화합니다. 
* **실시간 업데이트 (WebSocket)**: WebSocket을 통해 서버에서 발생하는 데이터 변경 사항을 모든 클라이언트에 실시간으로 푸시합니다. 
* **이벤트 배치 처리**: 단시간에 발생하는 여러 업데이트를 묶어서(batch) 전송하여 클라이언트의 렌더링 부하를 최소화합니다.
* **메타데이터 검색**: 노드와 센서의 이름 및 메타데이터를 검색할 수 있는 API와 UI를 제공합니다.
* **대화형 검색 결과 UI**: 여러 검색 결과가 있을 경우, 키보드와 마우스로 탐색 가능한 모달(Modal) 팝업을 통해 사용자 경험을 향상시킵니다.
* **자동 펼치기 및 하이라이트**: 검색 결과에서 항목을 선택하면, 트리에서 해당 위치까지의 모든 상위 폴더가 자동으로 펼쳐지고 선택된 항목이 하이라이트됩니다.

## **프로젝트 설정 및 실행 방법**

이 프로젝트는 bun을 런타임으로 사용하는 것을 권장합니다.

### **1. 의존성 설치**

프로젝트 루트 디렉토리에서 다음 명령어를 실행하여 필요한 모든 패키지를 설치합니다.

```shell
bun install
```

### **2. shadcn-vue 컴포넌트 추가**

이 프로젝트는 shadcn-vue의 UI 컴포넌트를 사용하지는 않지만, 초기 설정에는 포함되어 있습니다. 터미널에서 다음 명령어를 실행하여 기본 설정을 완료합니다.

```shell
bunx shadcn-vue@latest init
```

* 기본 설정을 그대로 사용하셔도 무방합니다 (Enter 키를 여러 번 누르세요).

### **3. 개발 서버 실행**

모든 설정이 완료되면, 다음 명령어로 개발 서버를 시작합니다.

```shell
bun run dev
```

이제 브라우저에서 http://localhost:3000으로 접속하면 구현된 트리 컴포넌트를 확인하고 모든 기능을 테스트해볼 수 있습니다.


# **아키텍처 분석: 메인 스레드 블로킹 방지 설계**

본 문서는 현재 구현된 트리 컴포넌트 아키텍처가 어떻게 메인 스레드(Main Thread)를 블로킹하지 않고 반응성을 유지하는지에 대해 기술적으로 분석한다. 이 설계의 핵심은 JavaScript의 비동기(Asynchronous) 처리 모델과 이벤트 루프(Event Loop)에 대한 깊은 이해를 바탕으로 한다.

## **1. 프론트엔드 (Vue.js)에서의 비동기 처리**

프론트엔드에서 메인 스레드는 사용자 인터랙션(클릭, 스크롤, 입력 등) 처리와 UI 렌더링이라는 막중한 임무를 담당한다. 따라서 시간이 오래 걸리는 작업(특히 네트워크 요청)이 메인 스레드를 점유하면, 애플리케이션은 즉시 "먹통"이 된다. 본 아키텍처는 이를 다음과 같이 방지한다.

### **1.1. 비동기 API 요청 (async/await와 fetch)**

* **fetchNodes, handleSearch 함수**: 이 함수들은 모두 async로 선언되어 있다. 내부의 fetch API 호출은 await 키워드와 함께 사용된다.  
* **작동 원리**:  
  1. fetch 함수가 호출되면, 브라우저는 즉시 네트워크 요청을 백그라운드 스레드로 위임하고, Promise 객체를 반환한다. 메인 스레드는 여기서 멈추지 않는다.  
  2. await 키워드는 fetch가 반환한 Promise가 완료(resolve 또는 reject)될 때까지 async 함수의 실행을 "일시 중단"시킨다.  
  3. 중요한 것은, 함수 실행이 중단되는 동안 **메인 스레드는 자유롭게 다른 작업을 수행**할 수 있다는 점이다. 사용자는 여전히 스크롤을 하거나 다른 버튼을 클릭할 수 있다.  
  4. 네트워크 응답이 도착하여 Promise가 완료되면, 이벤트 루프는 async 함수의 나머지 코드를 다시 실행 큐에 넣어 재개한다.

**결론**: 모든 데이터 요청은 백그라운드에서 처리되므로, 데이터를 불러오는 동안 UI는 완벽하게 반응성을 유지한다. isLoading 상태를 통해 사용자에게 로딩 중임을 시각적으로 알려주는 것은 이러한 비동기 처리의 사용자 경험을 극대화하는 패턴이다.

### **1.2. 이벤트 기반의 실시간 통신 및 배치 처리 (WebSocket)**

* **setupWebSocket 함수**: WebSocket 연결 및 메시지 수신은 모두 이벤트 기반으로 동작하며, 특히 대량의 이벤트를 효율적으로 처리하기 위한 배치(Batch) 처리 로직이 포함되어 있다.  
* **작동 원리**:  
  * **이벤트 기반 수신**: onmessage와 같은 이벤트 리스너를 통해 메시지가 도착했을 때만 관련 코드가 실행된다. 이는 메인 스레드가 불필요하게 대기하는 것을 막아준다.  
  * **배치 처리**: 서버는 짧은 시간 동안 발생한 다수의 업데이트를 즉시 전송하지 않고, 큐(Queue)에 모아둔다. 이후 주기적으로 이 큐에 쌓인 업데이트들을 **하나의 메시지(NODE\_UPDATES\_BATCH)로 묶어** 클라이언트에 전송한다.  
  * **효율적인 렌더링**: 클라이언트는 이 배치 메시지를 받은 후, 반복문을 통해 여러 상태 변경을 수행한다. Vue의 반응성 시스템은 이러한 다수의 상태 변경을 감지하고, 실제 DOM 업데이트는 단 한 번의 '틱(tick)'으로 모아서(batch) 처리한다. 결과적으로, 수십 개의 개별 메시지를 받았을 때 발생할 수 있는 잠재적인 렌더링 병목 현상을 방지하고 메인 스레드의 부담을 크게 줄인다.

**결론**: WebSocket 통신에 배치 처리 전략을 도입함으로써, 대량의 실시간 업데이트가 발생하더라도 최소한의 onmessage 이벤트 핸들링과 효율적인 단일 렌더링 주기를 통해 애플리케이션의 성능과 반응성을 높은 수준으로 유지한다.

## **2. 백엔드 (Nuxt.js / Node.js)에서의 비동기 처리**

Node.js(Nuxt.js 서버의 기반)는 "Non-blocking I/O" 모델을 기반으로 하는 싱글 스레드 이벤트 루프 아키텍처를 사용한다. 이는 백엔드에서도 블로킹을 최소화하는 데 매우 효율적이다.

### **2.1. 비동기 I/O 작업**

* **setTimeout을 이용한 지연 시뮬레이션**: 코드 내 await new Promise(resolve \=\> setTimeout(resolve, 500)) 부분은 I/O 작업(예: 데이터베이스 쿼리)을 흉내 낸다.  
* **작동 원리**:  
  1. setTimeout이 호출되면, 타이머는 백그라운드 API에 등록되고 Node.js는 즉시 다음 코드로 넘어간다. 스레드는 대기하지 않는다.  
  2. 500ms가 지나 타이머가 완료되면, 등록된 콜백(resolve)이 태스크 큐에 추가된다.  
  3. 이벤트 루프는 다른 요청을 처리하다가, 콜 스택이 비워지면 큐에 있던 콜백을 실행한다.

**결론**: 실제 DB 쿼리나 파일 시스템 접근과 같은 I/O 작업은 모두 이러한 비동기 방식으로 처리된다. 따라서 한 사용자의 요청이 DB에서 데이터를 기다리는 동안, 서버는 다른 수십, 수백 개의 요청을 동시에 효율적으로 처리할 수 있다.

### **2.2. 잠재적 블로킹 요소 및 해결책: search.post.ts**

* **동기적 검색 로직 (searchRecursive)**: 현재 Mock 데이터베이스를 검색하는 searchRecursive 함수는 동기적으로(Synchronously) 작동하는 순수 JavaScript 코드이다.  
* **분석**:  
  * 데이터가 수십만 개 이상으로 극단적으로 많아지면, 이 재귀 함수는 상당한 시간 동안 CPU를 점유하여 **서버의 이벤트 루프를 블로킹**할 수 있다. 이는 해당 시간 동안 서버가 다른 어떤 요청도 처리하지 못하게 됨을 의미한다.  
  * 프론트엔드와 달리, 이는 순수한 연산(Computation) 작업이므로 백그라운드로 자동 위임되지 않는다.  
* **프로덕션 환경에서의 개선 방안**:  
  1. **데이터베이스 인덱싱**: 실제 환경에서는 이러한 검색을 애플리케이션 메모리에서 수행하지 않는다. Oracle DB의 Full-Text Search나 적절한 인덱스를 활용하여 검색 작업을 DB 엔진에 위임해야 한다. DB는 이러한 작업을 매우 효율적으로 처리한다.  
  2. **Worker Threads**: 만약 반드시 애플리케이션 레벨에서 복잡한 연산을 해야 한다면, Node.js의 worker\_threads 모듈을 사용하여 해당 연산을 별도의 스레드에서 수행하고 결과만 메인 스레드로 받아야 한다.

## **3. 종합 결론**

현재 아키텍처는 프론트엔드와 백엔드 모두에서 JavaScript의 비동기 모델을 적극적으로 활용하여 **메인 스레드 블로킹을 효과적으로 방지**하고 있다. 특히 WebSocket 통신에 **이벤트 배치 처리**를 도입하여 대규모 실시간 업데이트 상황에서도 높은 반응성을 보장하도록 설계되었다.

다만, 서버의 동기식 검색 로직은 시스템이 극단적인 규모로 확장될 경우 잠재적인 성능 병목 지점이 될 수 있으며, 이는 데이터베이스 최적화나 워커 스레드 도입을 통해 해결해야 할 과제이다.
